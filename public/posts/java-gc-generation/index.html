<!doctype html><html lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>灰姑娘、贵族与垃圾回收：用"双层舞会"模型解构 Java GC 分代思想 | 季夏的个人博客</title><meta name=description content='灰姑娘、贵族与垃圾回收：用"双层舞会"模型解构 Java GC 分代思想

摘要：你是否想过，Java 虚拟机（JVM）管理内存的方式，像极了一场精心设计的皇家选妃？本文不谈枯燥的算法，而是通过一个"双层舞会"的寓言，带你理解为什么 JVM 要把对象分为"穷人"与"贵族"，以及守卫（GC）是如何在两场舞会之间进行筛选，防止灰姑娘被漏掉，同时避免舞池被无关人员挤爆。'><link rel=stylesheet href=/css/site.css></head><body><header class=site-header><div class="container header-inner"><div class=site-branding><div class=header-avatar><img src=/images/avatar.jpg alt=季夏></div><a href=/ class=site-title>季夏的个人博客</a></div><div class=header-search><input type=text id=search-input placeholder=搜索文章...><div id=search-results class=search-results></div></div><nav class=site-nav><ul><li><a href=/>首页</a></li><li><a href=/posts/>归档</a></li><li><a href=/tags/>标签</a></li></ul></nav></div></header><main class=site-main><div class=container><div class=article-layout><aside class=author-aside><div class="widget widget-author-info"><h3 class=widget-title>作者</h3><div class=author-box><a href=/posts/about/ class=author-link><div class=author-avatar><img src=/images/avatar.jpg alt=季夏></div><div class=author-info-text><h4 class=author-name>季夏</h4><p class=author-bio>个人博客</p><span class=view-more>查看详情 →</span></div></a></div></div><div class="widget widget-quote"><h3 class=widget-title>小记</h3><div class=widget-body><blockquote class=daily-quote><p>用双层舞会类比 Young Gen 和 Old Gen，理解分代 GC 的核心思想。</p></blockquote><blockquote class=daily-quote><p>大对象直接晋升老年代，既是优化也是风险。</p></blockquote><blockquote class=daily-quote><p>Card Table 机制解决跨代引用问题，避免全堆扫描。</p></blockquote></div></div><div class="widget widget-stats"><h3 class=widget-title>统计</h3><div class=widget-body><ul><li>📝 文章总数: 9</li><li>📁 分类数: 23</li><li>🏷️ 标签数: 48</li></ul></div></div></aside><article class=post-article><header class=article-header><h1 class=article-title>灰姑娘、贵族与垃圾回收：用"双层舞会"模型解构 Java GC 分代思想</h1><div class=post-meta><time>2025-12-02</time> · 5 分钟阅读
· 分类: <a href=/categories/%E6%8A%80%E6%9C%AF>技术</a> <a href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80>编程语言</a> <a href=/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91>后端开发</a> <a href=/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96>性能优化</a>
· 标签: <a href=/tags/java>Java</a> <a href=/tags/jvm>JVM</a> <a href=/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6>垃圾回收</a> <a href=/tags/gc>GC</a> <a href=/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86>内存管理</a> <a href=/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96>性能优化</a></div></header><div class=toc><details open><summary>目录</summary><nav class=toc-nav><nav id=TableOfContents><ul><li><a href=#引言王子的烦恼>引言：王子的烦恼</a></li><li><a href=#第一部分下层舞会--严酷的晋级赛young-generation>第一部分：下层舞会 —— 严酷的晋级赛（Young Generation）</a><ul><li><a href=#1-入场与狂欢eden-区>1. 入场与狂欢（Eden 区）</a></li><li><a href=#2-观察席的流转survivor-s0--s1>2. 观察席的流转（Survivor S0 & S1）</a></li><li><a href=#3-守卫的筛选规则minor-gc--copying>3. 守卫的筛选规则（Minor GC & Copying）</a></li></ul></li><li><a href=#第二部分上层舞会--皇宫的荣耀old-generation>第二部分：上层舞会 —— 皇宫的荣耀（Old Generation）</a><ul><li><a href=#1-晋升时刻promotion>1. 晋升时刻（Promotion）</a></li><li><a href=#2-王子的筛选majorfull-gc>2. 王子的筛选（Major/Full GC）</a></li></ul></li><li><a href=#第三部分贵族的特权--权势与概率的博弈large-objects>第三部分：贵族的特权 —— 权势与概率的博弈（Large Objects）</a><ul><li><a href=#1-权势极大难以撼动>1. 权势极大，难以撼动</a></li><li><a href=#2-受教育高胜算大>2. 受教育高，胜算大</a></li><li><a href=#3-特权通道>3. 特权通道</a></li></ul></li><li><a href=#第四部分灰姑娘的危机--跨代引用cross-reference>第四部分：灰姑娘的危机 —— 跨代引用（Cross-Reference）</a><ul><li><a href=#解决方案贵族的名册card-table>解决方案：贵族的名册（Card Table）</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></nav></details></div><div class=article-content><h1 id=灰姑娘贵族与垃圾回收用双层舞会模型解构-java-gc-分代思想>灰姑娘、贵族与垃圾回收：用"双层舞会"模型解构 Java GC 分代思想</h1><blockquote><p><strong>摘要</strong>：你是否想过，Java 虚拟机（JVM）管理内存的方式，像极了一场精心设计的皇家选妃？本文不谈枯燥的算法，而是通过一个"双层舞会"的寓言，带你理解为什么 JVM 要把对象分为"穷人"与"贵族"，以及守卫（GC）是如何在两场舞会之间进行筛选，防止灰姑娘被漏掉，同时避免舞池被无关人员挤爆。</p></blockquote><hr><h2 id=引言王子的烦恼>引言：王子的烦恼</h2><p>在遥远的 Java 王国，王子（JVM）面临着一个棘手的问题：他需要找到一位完美的妻子（长期存活的有价值对象）。</p><p>起初，王子决定举办一场盛大的舞会，允许全国所有人直接进入皇宫舞池。结果可想而知：舞池瞬间爆满，绝大多数人只是来凑热闹的（朝生夕死的短命对象），王子在人海中根本找不到灰姑娘。更糟糕的是，每次为了腾出空间，守卫必须把皇宫翻个底朝天（Full GC），把所有人都赶出去重新排队，这导致整个王国陷入停顿（Stop-The-World），效率极低。</p><p>皇家顾问发现了一个规律（<strong>弱分代假说</strong>）：<strong>绝大多数人只是匆匆过客，只有极少数人值得留在皇宫。</strong></p><p>于是，一套高效的“双层舞会”机制应运而生。</p><hr><h2 id=第一部分下层舞会--严酷的晋级赛young-generation>第一部分：下层舞会 —— 严酷的晋级赛（Young Generation）</h2><p>为了不让皇宫被挤爆，所有平民（新对象）必须先参加在广场举办的“下层舞会”。但这不仅仅是一场舞会，而是一场<strong>多轮制的生存挑战赛</strong>。</p><h3 id=1-入场与狂欢eden-区>1. 入场与狂欢（Eden 区）</h3><p>所有刚出生的对象，首先都会进入广场中央的<strong>入场区（Eden）</strong>。这里是最热闹、最拥挤的地方，大家尽情狂欢。</p><h3 id=2-观察席的流转survivor-s0--s1>2. 观察席的流转（Survivor S0 & S1）</h3><p>广场旁边设有两个专门的 VIP 观察席：<strong>观察席 A</strong> 和 <strong>观察席 B</strong>（对应 Survivor From/To）。规则是：<strong>任何时候只有一个观察席开放，另一个必须保持清空</strong>，随时准备接收下一轮的幸存者。</p><h3 id=3-守卫的筛选规则minor-gc--copying>3. 守卫的筛选规则（Minor GC & Copying）</h3><p>当入场区人满为患时，守卫吹响哨子，开始清理：</p><ol><li><strong>第一轮清洗</strong>：绝大多数在入场区凑热闹的人（垃圾对象）立刻被清理出局。</li><li><strong>幸存者的转移</strong>：那些还在跳舞、有人搭理的（存活对象），会被守卫带到<strong>观察席 A</strong>。此时，守卫会在他们的胸口盖上一个章：“<strong>通过第 1 轮</strong>”。</li><li><strong>多轮晋级（Ageing）</strong>：<ul><li>下一场舞会开始，新人继续填满入场区。</li><li>再次清理时，守卫不仅检查入场区，还会检查<strong>观察席 A</strong>。</li><li>还活着的人（包括入场区的新幸存者 + 观察席 A 的老幸存者）统统被转移到<strong>观察席 B</strong>。</li><li><strong>关键点</strong>：之前在观察席 A 的人，胸口的章变成了“<strong>通过第 2 轮</strong>”。</li></ul></li><li><strong>清空与交换</strong>：原来的入场区和观察席 A 此时被彻底清扫干净，为下一轮做准备。</li></ol><blockquote><p><strong>技术映射</strong>：</p><ul><li><strong>Eden + 2 Survivor</strong>：年轻代的标准布局。</li><li><strong>复制算法（Copying）</strong>：对象在 S0 和 S1 之间反复横跳，避免了内存碎片。</li><li><strong>对象年龄（Object Age）</strong>：对象头（Mark Word）里记录的分代年龄，每熬过一次 GC 加 1。</li></ul></blockquote><hr><h2 id=第二部分上层舞会--皇宫的荣耀old-generation>第二部分：上层舞会 —— 皇宫的荣耀（Old Generation）</h2><h3 id=1-晋升时刻promotion>1. 晋升时刻（Promotion）</h3><p>守卫有一个严格的标准（<strong>MaxTenuringThreshold</strong>，比如 15 轮）。只有当一个人胸口的章盖满了 15 个，证明了他拥有极强的生命力，守卫才会恭敬地打开通往皇宫的大门：“恭喜，您已经证明了自己的耐力，请去<strong>上层舞会</strong>吧。”</p><h3 id=2-王子的筛选majorfull-gc>2. 王子的筛选（Major/Full GC）</h3><p>上层舞会里的人虽然少，但个个都是“老油条”。王子很少来这里清理，因为这里的每一位都经过了层层选拔。但一旦这里也满了，王子就不得不进行一次<strong>大清洗（Full GC）</strong>。这代价非常昂贵，需要暂停所有音乐，仔细盘查每一位贵宾，往往会导致长时间的冷场。</p><hr><h2 id=第三部分贵族的特权--权势与概率的博弈large-objects>第三部分：贵族的特权 —— 权势与概率的博弈（Large Objects）</h2><p>舞会偶尔会来一些显赫的<strong>贵族</strong>（大对象，如长数组、大缓冲区）。对于他们，规则有所不同。</p><h3 id=1-权势极大难以撼动>1. 权势极大，难以撼动</h3><p>普通平民（小对象）在下层舞会的观察席之间被推来推去（复制）很容易，但要移动一位权势滔天的贵族，需要耗费守卫巨大的精力（CPU 和内存带宽），甚至可能因为为了安顿他而搞乱整个舞会的秩序。</p><h3 id=2-受教育高胜算大>2. 受教育高，胜算大</h3><p>贵族通常家学渊源，他们往往肩负重任（承载重要数据），不是来随便逛逛的。从概率上讲，他们成为“好妻子”（长期存活）的可能性本来就比普通人高。</p><h3 id=3-特权通道>3. 特权通道</h3><p>为了避免在下层舞会里频繁请动这些大人物造成资源浪费，守卫允许他们<strong>跳过选拔，直接进入上层舞会</strong>。</p><blockquote><p><strong>技术映射</strong>：</p><ul><li><strong>复制成本（Copying Cost）</strong>：大对象在 Survivor 区之间复制开销极大。</li><li><strong>PretenureSizeThreshold</strong>：超过该大小的对象直接在老年代分配。</li><li><strong>风险</strong>：如果这位贵族其实是个“败家子”（短命的大对象），他会长期占用宝贵的皇宫空间，导致 Full GC 提前到来。</li></ul></blockquote><hr><h2 id=第四部分灰姑娘的危机--跨代引用cross-reference>第四部分：灰姑娘的危机 —— 跨代引用（Cross-Reference）</h2><p>这里有一个潜在的危机：如果灰姑娘还在下层舞会（年轻代），但她被上层舞会的一位贵族看上了（老年代对象引用了年轻代对象）。</p><p>当守卫清理下层舞会时，他怎么知道灰姑娘不能赶走？难道要跑去皇宫把所有贵族问一遍吗？那太慢了！</p><h3 id=解决方案贵族的名册card-table>解决方案：贵族的名册（Card Table）</h3><p>贵族手里有一本<strong>名册（Card Table / Remembered Set）</strong>。每当贵族关注了下层舞会的某个人，他就会在名册上记一笔（写屏障 Write Barrier）。</p><p>守卫清理下层舞会时，只需要快速翻一下这本名册。凡是名册上提到的人，哪怕在下层舞会看似没人理，也不能赶走。</p><hr><h2 id=总结>总结</h2><p>Java 的内存管理，就是一场在混乱中寻找秩序的盛大舞会。</p><ul><li><strong>下层舞会（Young Gen）</strong> 利用了“大多数对象朝生夕死”的规律，通过**多轮筛选（Copying）**快速清理垃圾。</li><li><strong>上层舞会（Old Gen）</strong> 为长期存活的对象提供了稳定的居所，避免了频繁的搬运。</li><li><strong>贵族特权（Large Objects）</strong> 权衡了<strong>移动成本</strong>与<strong>存活概率</strong>，避免了笨重的复制。</li></ul><p>理解了这个模型，你就理解了为什么我们需要调整 <code>-XX:SurvivorRatio</code>（观察席大小），为什么要关注 <code>-XX:MaxTenuringThreshold</code>（晋级门槛），以及为什么大对象直接进老年代既是优化也是风险。</p></div><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelector(".post-article"),t=document.querySelectorAll(".toc-nav a");t.forEach(t=>{t.addEventListener("click",function(t){t.preventDefault();const s=this.getAttribute("href").substring(1),n=document.getElementById(s);if(n&&e){const t=e.getBoundingClientRect(),s=n.getBoundingClientRect(),o=e.scrollTop,i=s.top-t.top+o-20;e.scrollTo({top:i,behavior:"smooth"})}})})})</script><div class=post-nav style="margin-top:40px;padding-top:20px;border-top:1px solid var(--border);display:flex;justify-content:space-between"><a href=/posts/go-first-impression/>← Go语言初体验</a></div></article><aside class=sidebar><div class="widget widget-author"><h3 class=widget-title>关于我</h3><div class=widget-body><p>个人博客</p><a href=/posts/about/ class=widget-link>了解更多 →</a></div></div><div class="widget widget-categories"><h3 class=widget-title>分类</h3><div class=widget-body><ul><li><a href=/categories/devops>devops</a> (1)</li><li><a href=/categories/ui%E8%AE%BE%E8%AE%A1>ui设计</a> (1)</li><li><a href=/categories/web%E5%BC%80%E5%8F%91>web开发</a> (2)</li><li><a href=/categories/%E4%BA%91%E8%AE%A1%E7%AE%97>云计算</a> (1)</li><li><a href=/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD>人工智能</a> (1)</li><li><a href=/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91>前端开发</a> (1)</li><li><a href=/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91>后端开发</a> (2)</li><li><a href=/categories/%E5%AE%B9%E5%99%A8%E5%8C%96>容器化</a> (1)</li><li><a href=/categories/%E5%B7%A5%E5%85%B7>工具</a> (1)</li><li><a href=/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96>性能优化</a> (2)</li><li><a href=/categories/%E6%8A%80%E6%9C%AF>技术</a> (6)</li><li><a href=/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87>效率提升</a> (1)</li><li><a href=/categories/%E6%95%99%E7%A8%8B>教程</a> (1)</li><li><a href=/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90>数据分析</a> (1)</li><li><a href=/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6>数据科学</a> (1)</li><li><a href=/categories/%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99>文档编写</a> (1)</li><li><a href=/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0>机器学习</a> (1)</li><li><a href=/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F>生活感悟</a> (1)</li><li><a href=/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91>移动开发</a> (1)</li><li><a href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80>编程语言</a> (2)</li><li><a href=/categories/%E8%BF%90%E7%BB%B4>运维</a> (1)</li><li><a href=/categories/%E9%9A%8F%E7%AC%94>随笔</a> (1)</li><li><a href=/categories/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99>静态网站</a> (1)</li></ul></div></div><div class="widget widget-tags"><h3 class=widget-title>标签</h3><div class="widget-body tags-cloud"><a href=/tags/angular>angular</a>
<a href=/tags/ci/cd>ci/cd</a>
<a href=/tags/devops>devops</a>
<a href=/tags/docker>docker</a>
<a href=/tags/gc>gc</a>
<a href=/tags/github-pages>github pages</a>
<a href=/tags/go>go</a>
<a href=/tags/hugo>hugo</a>
<a href=/tags/java>java</a>
<a href=/tags/javascript>javascript</a>
<a href=/tags/jvm>jvm</a>
<a href=/tags/kubernetes>kubernetes</a>
<a href=/tags/markdown>markdown</a>
<a href=/tags/numpy>numpy</a>
<a href=/tags/pandas>pandas</a>
<a href=/tags/python>python</a>
<a href=/tags/react>react</a>
<a href=/tags/typescript>typescript</a>
<a href=/tags/vue>vue</a>
<a href=/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF>个人成长</a>
<a href=/tags/%E4%BA%91%E5%8E%9F%E7%94%9F>云原生</a>
<a href=/tags/%E5%85%A5%E9%97%A8>入门</a>
<a href=/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86>内存管理</a>
<a href=/tags/%E5%86%99%E4%BD%9C>写作</a>
<a href=/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6>前端框架</a>
<a href=/tags/%E5%8D%9A%E5%AE%A2>博客</a>
<a href=/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6>垃圾回收</a>
<a href=/tags/%E5%AE%B9%E5%99%A8>容器</a>
<a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程</a>
<a href=/tags/%E5%BC%80%E5%A7%8B>开始</a>
<a href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1>微服务</a>
<a href=/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96>性能优化</a>
<a href=/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96>数据可视化</a>
<a href=/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86>数据处理</a>
<a href=/tags/%E6%96%87%E6%A1%A3>文档</a>
<a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0>机器学习</a>
<a href=/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96>格式化</a>
<a href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0>深度学习</a>
<a href=/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86>状态管理</a>
<a href=/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B>生产力</a>
<a href=/tags/%E7%AC%94%E8%AE%B0>笔记</a>
<a href=/tags/%E7%BB%84%E4%BB%B6%E5%8C%96>组件化</a>
<a href=/tags/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90>统计分析</a>
<a href=/tags/%E7%BC%96%E8%BE%91%E5%99%A8>编辑器</a>
<a href=/tags/%E8%87%AA%E5%8A%A8%E5%8C%96>自动化</a>
<a href=/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2>自动化部署</a>
<a href=/tags/%E9%83%A8%E7%BD%B2>部署</a>
<a href=/tags/%E9%95%9C%E5%83%8F>镜像</a></div></div><div class="widget widget-recent"><h3 class=widget-title>最新文章</h3><div class=widget-body><ul><li><a href=/posts/java-gc-generation/>灰姑娘、贵族与垃圾回收：用"双层舞会"模型解构 Java GC 分代思想</a></li><li><a href=/posts/go-first-impression/>Go语言初体验</a></li><li><a href=/posts/hugo-guide/>Hugo博客搭建指南</a></li><li><a href=/posts/welcome/>欢迎来到我的博客</a></li><li><a href=/posts/markdown-tips/>Markdown写作技巧</a></li></ul></div></div></aside></div></div></main><footer class=site-footer><div class=container><p>&copy; 2025 季夏. All rights reserved.</p></div></footer><script>const searchInput=document.getElementById("search-input"),searchResults=document.getElementById("search-results");if(searchInput){const t=[{title:'"灰姑娘、贵族与垃圾回收：用\\"双层舞会\\"模型解构 Java GC 分代思想"',url:"https://jixia8.github.io/posts/java-gc-generation/",date:"2025-12-02",summary:'"灰姑娘、贵族与垃圾回收：用\\u0026quot;双层舞会\\u0026quot;模型解构 Java GC 分代思想 摘要：你是否想过，Java 虚拟机（JVM）管理内存的方式，像极了一场精心设计的皇家选妃？本文不谈枯燥的算 …"'},{title:'"Go语言初体验"',url:"https://jixia8.github.io/posts/go-first-impression/",date:"2025-12-02",summary:`"为什么选择 Go 最近开始学习 Go 语言，发现它有很多吸引人的特点。\\n简洁的语法 Go 的语法非常简洁，没有 Java 那么繁琐。一个简单的 Hello World：\\npackage main …"`},{title:'"Hugo博客搭建指南"',url:"https://jixia8.github.io/posts/hugo-guide/",date:"2025-12-02",summary:`"前言 使用 Hugo 和 GitHub Pages 搭建个人博客是一个简单又高效的方案。本文记录了我搭建这个博客的完整过程。\\n什么是 Hugo Hugo 是一个用 Go 语言编写的静态网站生成器，具有 …"`},{title:'"欢迎来到我的博客"',url:"https://jixia8.github.io/posts/welcome/",date:"2025-12-02",summary:`"关于这个博客 这是我的个人博客，用来记录学习和生活中的点滴。\\n我会写什么 在这个博客里，我会分享：\\n技术学习笔记 项目开发经验 生活感悟与思考 读书笔记 为什么要写博客 写博客是一个很好的习惯：\\n整理 …"`},{title:'"Markdown写作技巧"',url:"https://jixia8.github.io/posts/markdown-tips/",date:"2025-12-02",summary:`"Markdown 简介 Markdown 是一种轻量级标记语言，让你专注于内容而不是格式。\\n基础语法 标题 使用 # 创建标题，几个 # 就是几级标题。\\n强调 粗体：使用 **文字** 斜体：使用 * …"`},{title:'"关于我"',url:"https://jixia8.github.io/posts/about/",date:"2025-12-02",summary:`"👋 你好，我是季夏 欢迎来到我的个人博客！这里是我记录学习、分享技术、思考人生的地方。\\n🎯 关于这个博客 这个博客创建于 2025 年，使用 Hugo 搭建，托管在 GitHub Pages 上。我希 …"`},{title:'"Docker容器化部署实践"',url:"https://jixia8.github.io/posts/docker-deployment/",date:"2025-12-01",summary:`"Docker 简介 Docker 是容器化技术的代表。\\n基本命令 docker build -t myapp . docker run -p 8080:8080 myapp Kubernetes 容器 …"`},{title:'"前端开发框架对比"',url:"https://jixia8.github.io/posts/frontend-frameworks/",date:"2025-12-01",summary:'"主流框架 React 组件化开发 虚拟 DOM 生态丰富 Vue 渐进式框架 双向绑定 简单易学 Angular 企业级框架 TypeScript 完整解决方案 选择建议 根据项目需求选择合适的框架。 …"'},{title:'"Python数据分析实战"',url:"https://jixia8.github.io/posts/python-data-analysis/",date:"2025-12-01",summary:`"数据分析简介 Python 是数据分析的首选语言。\\n常用库 Pandas：数据处理 NumPy：数值计算 Matplotlib：可视化 示例代码 import pandas as pd import …"`}];let e=-1;function updateResults(n){if(n.length<2){searchResults.classList.remove("active"),e=-1;return}const s=t.filter(e=>e.title.toLowerCase().includes(n)||e.summary.toLowerCase().includes(n)).slice(0,8);s.length>0?(searchResults.innerHTML=s.map((e,t)=>`
                    <a href="${e.url}" class="search-result-item" data-index="${t}">
                        <div class="search-result-title">${e.title}</div>
                        <div class="search-result-meta">${e.date}</div>
                    </a>
                `).join(""),searchResults.classList.add("active"),e=-1):(searchResults.innerHTML='<div class="search-result-item no-click">未找到相关文章</div>',searchResults.classList.add("active"),e=-1)}searchInput.addEventListener("input",function(e){const t=e.target.value.toLowerCase().trim();updateResults(t)}),searchInput.addEventListener("keydown",function(t){const n=searchResults.querySelectorAll(".search-result-item:not(.no-click)");t.key==="ArrowDown"?(t.preventDefault(),e===-1?e=0:e=Math.min(e+1,n.length-1),updateSelection(n)):t.key==="ArrowUp"?(t.preventDefault(),e=Math.max(e-1,-1),updateSelection(n)):t.key==="Enter"?(t.preventDefault(),e>=0&&n[e]&&(window.location.href=n[e].href)):t.key==="Escape"&&(searchResults.classList.remove("active"),e=-1)});function updateSelection(t){t.forEach((t,n)=>{n===e?t.classList.add("selected"):t.classList.remove("selected")})}document.addEventListener("click",function(t){!searchInput.contains(t.target)&&!searchResults.contains(t.target)&&(searchResults.classList.remove("active"),e=-1)})}</script></body></html>